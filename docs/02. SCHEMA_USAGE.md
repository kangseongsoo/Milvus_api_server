# 📋 스키마 사용법 가이드

## 📖 개요

이 문서는 PostgreSQL과 Milvus 스키마를 중앙화된 방식으로 관리하고 사용하는 방법을 설명합니다.

- **PostgreSQL 스키마**: `app/schemas/postgres_schema.py`
- **Milvus 스키마**: `app/schemas/milvus_schema.py`
- **메타데이터 관리**: `app/schemas/milvus_metadata.py`

## 🗄️ PostgreSQL 스키마

### **파일 위치**
```
app/schemas/postgres_schema.py
```

### **주요 구성 요소**

#### **1️⃣ 테이블 스키마**
```python
DOCUMENTS_TABLE_SCHEMA = """
CREATE TABLE IF NOT EXISTS documents (
    doc_id BIGSERIAL PRIMARY KEY,
    chat_bot_id VARCHAR(100) NOT NULL,
    content_name VARCHAR(500) NOT NULL,
    chunk_count INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    metadata JSONB,
    UNIQUE(chat_bot_id, content_name)
);
"""

DOCUMENT_CHUNKS_TABLE_SCHEMA = """
CREATE TABLE IF NOT EXISTS document_chunks (
    chunk_id BIGSERIAL PRIMARY KEY,
    doc_id BIGINT REFERENCES documents(doc_id) ON DELETE CASCADE,
    chat_bot_id VARCHAR(100) NOT NULL,
    chunk_index INT NOT NULL,
    chunk_text TEXT NOT NULL,
    UNIQUE(doc_id, chunk_index)
);
"""
```

#### **2️⃣ 인덱스 스키마**
```python
INDEXES_SCHEMA = """
CREATE INDEX IF NOT EXISTS idx_documents_chat_bot_id ON documents(chat_bot_id);
CREATE INDEX IF NOT EXISTS idx_documents_content_name ON documents(content_name);
CREATE INDEX IF NOT EXISTS idx_documents_created_at ON documents(created_at);
CREATE INDEX IF NOT EXISTS idx_documents_metadata ON documents USING GIN(metadata);
CREATE INDEX IF NOT EXISTS idx_chunks_doc_id ON document_chunks(doc_id);
"""
```

#### **3️⃣ 통합 SQL 생성**
```python
def get_init_sql() -> str:
    """
    초기 테이블 생성 SQL 반환
    
    Returns:
        전체 초기화 SQL
    """
    return f"""
{DOCUMENTS_TABLE_SCHEMA}

{DOCUMENT_CHUNKS_TABLE_SCHEMA}

{INDEXES_SCHEMA}
"""
```

### **사용법**

#### **PostgreSQL 클라이언트에서 사용**
```python
from app.schemas.postgres_schema import get_init_sql

# 스키마 파일에서 SQL 가져오기
init_sql = get_init_sql()

# 데이터베이스에 실행
async with conn.transaction():
    await conn.execute(init_sql)
```

#### **마이그레이션에서 사용**
```python
from app.schemas.postgres_schema import DOCUMENTS_TABLE_SCHEMA, INDEXES_SCHEMA

# 특정 테이블만 사용
await conn.execute(DOCUMENTS_TABLE_SCHEMA)
await conn.execute(INDEXES_SCHEMA)
```

---

## 🎯 Milvus 스키마

### **파일 위치**
```
app/schemas/milvus_schema.py
```

### **주요 구성 요소**

#### **1️⃣ 컬렉션 스키마 생성**
```python
def create_collection_schema(dimension: int = 1536, use_sparse: bool = False) -> CollectionSchema:
    """
    Milvus 컬렉션 스키마 생성
    
    Args:
        dimension: Dense 벡터 차원
        use_sparse: Sparse 임베딩 사용 여부
    
    Returns:
        CollectionSchema 객체
    """
    fields = [
        FieldSchema(
            name="id",
            dtype=DataType.INT64,
            is_primary=True,
            auto_id=True,
            description="청크 고유 ID (자동 생성)"
        ),
        FieldSchema(
            name="doc_id",
            dtype=DataType.INT64,
            description="문서 ID (PostgreSQL FK)"
        ),
        FieldSchema(
            name="chat_bot_id",
            dtype=DataType.VARCHAR,
            max_length=100,
            description="챗봇 ID (파티션 키)"
        ),
        FieldSchema(
            name="content_name",
            dtype=DataType.VARCHAR,
            max_length=500,
            description="문서 고유 식별자 (URL, 파일명, 제목 등)"
        ),
        FieldSchema(
            name="chunk_index",
            dtype=DataType.INT64,
            description="청크 순서 (0부터 시작)"
        ),
        FieldSchema(
            name="embedding_dense",
            dtype=DataType.FLOAT_VECTOR,
            dim=dimension,
            description="Dense 임베딩 벡터"
        ),
        FieldSchema(
            name="metadata",
            dtype=DataType.JSON,
            description="메타데이터 (JSON 형태, expr 필터링용)"
        )
    ]
    
    # Sparse 임베딩 필드 추가 (하이브리드 검색용)
    if use_sparse:
        fields.append(
            FieldSchema(
                name="embedding_sparse",
                dtype=DataType.SPARSE_FLOAT_VECTOR,
                description="Sparse 임베딩 벡터 (하이브리드 검색)"
            )
        )
    
    schema = CollectionSchema(
        fields=fields,
        description="RAG 문서 벡터 컬렉션 (파티셔닝 + JSON 메타데이터)"
    )
    
    return schema
```

#### **2️⃣ 인덱스 파라미터**
```python
def get_index_params():
    """
    벡터 인덱스 파라미터 반환
    
    Returns:
        인덱스 설정 딕셔너리
    """
    return {
        "index_type": "HNSW",
        "metric_type": "COSINE",
        "params": {
            "M": 8,              # 그래프 연결 수 (높을수록 정확하지만 느림)
            "efConstruction": 64  # 인덱스 구축 시 탐색 범위
        }
    }
```

#### **3️⃣ 검색 파라미터**
```python
def get_search_params():
    """
    검색 파라미터 반환
    
    Returns:
        검색 설정 딕셔너리
    """
    return {
        "metric_type": "COSINE",
        "params": {
            "ef": 64  # 검색 시 탐색 범위 (높을수록 정확하지만 느림)
        }
    }
```

### **사용법**

#### **Milvus 클라이언트에서 사용**
```python
from app.schemas.milvus_schema import create_collection_schema, get_index_params

# 스키마 생성
schema = create_collection_schema(
    dimension=1536,
    use_sparse=settings.USE_SPARSE_EMBEDDING
)

# 컬렉션 생성
collection = Collection(name=collection_name, schema=schema)

# 인덱스 생성
index_params = get_index_params()
collection.create_index(
    field_name="embedding_dense",
    index_params=index_params
)
```

#### **검색에서 사용**
```python
from app.schemas.milvus_schema import get_search_params

# 검색 파라미터 사용
search_params = get_search_params()
results = collection.search(
    data=[query_vector],
    anns_field="embedding_dense",
    param=search_params,
    limit=5
)
```

---

## 🏷️ 메타데이터 관리

### **파일 위치**
```
app/schemas/milvus_metadata.py
```

### **주요 기능**

#### **1️⃣ Milvus 필터링 필드 관리**
```python
# config.py에서 정의된 필터링 필드
MILVUS_METADATA_FIELDS = [
    "content_type", "source_type", "language", "tags", "category",
    "author", "department", "created_date", "page_count", "file_size",
    "status", "priority", "is_public", "has_attachments"
]
```

#### **2️⃣ 메타데이터 분리 함수**
```python
def filter_milvus_metadata(all_metadata: dict) -> dict:
    """
    전체 메타데이터에서 Milvus 필터링용 필드만 추출
    
    Args:
        all_metadata: 전체 메타데이터 딕셔너리
    
    Returns:
        Milvus 필터링용 메타데이터 딕셔너리
    """
    milvus_metadata = {}
    for field in settings.MILVUS_METADATA_FIELDS:
        if field in all_metadata:
            milvus_metadata[field] = all_metadata[field]
    
    return milvus_metadata
```

#### **3️⃣ 유틸리티 함수**
```python
def get_milvus_metadata_fields() -> list:
    """Milvus 메타데이터 필드 목록 반환"""
    return settings.MILVUS_METADATA_FIELDS.copy()

def is_milvus_metadata_field(field_name: str) -> bool:
    """특정 필드가 Milvus 메타데이터 필드인지 확인"""
    return field_name in settings.MILVUS_METADATA_FIELDS
```

### **사용법**

#### **데이터 삽입 시 메타데이터 분리**
```python
from app.schemas.milvus_metadata import filter_milvus_metadata

# 전체 메타데이터
all_metadata = {
    "title": "AI 가이드",
    "author": "김개발",
    "content_type": "html",
    "source_type": "url",
    "tags": ["AI", "머신러닝"],
    "page_count": 120,
    "created_date": "2024-01-01",
    "internal_notes": "내부 메모",  # Milvus 필터링 필드 아님
    "confidential": True  # Milvus 필터링 필드 아님
}

# Milvus용 메타데이터 분리
milvus_metadata = filter_milvus_metadata(all_metadata)
# 결과: {"content_type": "html", "source_type": "url", "tags": ["AI", "머신러닝"], "page_count": 120, "created_date": "2024-01-01"}

# PostgreSQL용 (전체 메타데이터)
postgres_metadata = all_metadata
```

---

## 🔧 스키마 수정 방법

### **PostgreSQL 스키마 수정**

#### **1️⃣ 필드 추가**
```python
# postgres_schema.py 수정
DOCUMENTS_TABLE_SCHEMA = """
CREATE TABLE IF NOT EXISTS documents (
    doc_id BIGSERIAL PRIMARY KEY,
    chat_bot_id VARCHAR(100) NOT NULL,
    content_name VARCHAR(500) NOT NULL,
    new_field VARCHAR(255),  -- 새 필드 추가
    chunk_count INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    metadata JSONB,
    UNIQUE(chat_bot_id, content_name)
);
"""
```

#### **2️⃣ 인덱스 추가**
```python
INDEXES_SCHEMA = """
CREATE INDEX IF NOT EXISTS idx_documents_chat_bot_id ON documents(chat_bot_id);
CREATE INDEX IF NOT EXISTS idx_documents_content_name ON documents(content_name);
CREATE INDEX IF NOT EXISTS idx_documents_new_field ON documents(new_field);  -- 새 인덱스
CREATE INDEX IF NOT EXISTS idx_documents_created_at ON documents(created_at);
CREATE INDEX IF NOT EXISTS idx_documents_metadata ON documents USING GIN(metadata);
CREATE INDEX IF NOT EXISTS idx_chunks_doc_id ON document_chunks(doc_id);
"""
```

### **Milvus 스키마 수정**

#### **1️⃣ 필드 추가**
```python
# milvus_schema.py 수정
def create_collection_schema(dimension: int = 1536, use_sparse: bool = False) -> CollectionSchema:
    fields = [
        # 기존 필드들...
        FieldSchema(
            name="new_field",
            dtype=DataType.VARCHAR,
            max_length=255,
            description="새로운 필드"
        ),
        # 나머지 필드들...
    ]
```

#### **2️⃣ 인덱스 파라미터 수정**
```python
def get_index_params():
    return {
        "index_type": "HNSW",
        "metric_type": "COSINE",
        "params": {
            "M": 16,  # 성능 향상을 위해 증가
            "efConstruction": 128  # 정확도 향상을 위해 증가
        }
    }
```

### **메타데이터 필드 수정**

#### **1️⃣ 필터링 필드 추가**
```python
# config.py 수정
MILVUS_METADATA_FIELDS: list = [
    "content_type", "source_type", "language", "tags", "category",
    "author", "department", "created_date", "page_count", "file_size",
    "status", "priority", "is_public", "has_attachments",
    "new_filter_field"  # 새 필터링 필드 추가
]
```

---

## 📊 스키마 버전 관리

### **버전별 변경사항 추적**

#### **v1.0 (초기 버전)**
- 기본 PostgreSQL 테이블 구조
- Milvus 컬렉션 기본 스키마

#### **v1.1 (content_name 추가)**
- `content` 필드 → `content_name` 필드로 변경
- 유니크 제약조건 추가
- Milvus에 `content_name` 필드 추가

#### **v1.2 (embedding_sparse 추가)**
- Milvus에 `embedding_sparse` 필드 추가
- 하이브리드 검색 준비

### **마이그레이션 가이드**

#### **기존 데이터베이스 업데이트**
```sql
-- 1. content_name 필드 추가
ALTER TABLE documents ADD COLUMN content_name VARCHAR(500);

-- 2. 기존 데이터 마이그레이션
UPDATE documents SET content_name = COALESCE(
    metadata->>'source_url',
    metadata->>'title',
    'document_' || doc_id::text
) WHERE content_name IS NULL;

-- 3. NOT NULL 제약조건 추가
ALTER TABLE documents ALTER COLUMN content_name SET NOT NULL;

-- 4. 유니크 제약조건 추가
ALTER TABLE documents ADD CONSTRAINT unique_document_per_bot 
UNIQUE(chat_bot_id, content_name);

-- 5. content 필드 제거 (선택사항)
ALTER TABLE documents DROP COLUMN content;
```

---

## ⚠️ 주의사항

### **스키마 변경 시 고려사항**

1. **하위 호환성**: 기존 데이터와의 호환성 확인
2. **인덱스 재구성**: 필드 추가/삭제 시 인덱스 재구성 필요
3. **마이그레이션**: 기존 데이터 마이그레이션 계획
4. **성능 영향**: 인덱스 변경이 성능에 미치는 영향 평가

### **테스트 방법**

#### **1️⃣ 스키마 검증**
```python
# PostgreSQL 스키마 테스트
from app.schemas.postgres_schema import get_init_sql
print(get_init_sql())  # SQL 문법 검증

# Milvus 스키마 테스트
from app.schemas.milvus_schema import create_collection_schema
schema = create_collection_schema(dimension=1536, use_sparse=True)
print(schema)  # 스키마 구조 검증
```

#### **2️⃣ 통합 테스트**
```python
# 전체 시스템 테스트
async def test_schema_integration():
    # PostgreSQL 테이블 생성
    await postgres_client.initialize_tables("test_account")
    
    # Milvus 컬렉션 생성
    await milvus_client.create_collection("test_account", dimension=1536)
    
    # 데이터 삽입 테스트
    # 검색 테스트
```

---

## 🔗 관련 문서

- [문서 삽입 API](./01. INSERT_DOCUMENT.md)
- [ERD 다이어그램](./ERD.md)
- [아키텍처 문서](./ARCHITECTURE.md)
- [메타데이터 필터링](./METADATA_FILTERING.md)

---

## 📝 요약

### **✅ 장점**
- **중앙화된 관리**: 모든 스키마가 한 곳에서 관리됨
- **일관성 보장**: PostgreSQL과 Milvus 스키마 동기화
- **유지보수성**: 스키마 변경 시 한 곳만 수정
- **재사용성**: 여러 곳에서 동일한 스키마 사용

### **🎯 사용 원칙**
1. **스키마 파일 우선**: 하드코딩 대신 스키마 파일 사용
2. **버전 관리**: 스키마 변경사항 문서화
3. **테스트 필수**: 스키마 변경 후 반드시 테스트
4. **마이그레이션**: 기존 데이터 호환성 고려

**이제 모든 스키마가 중앙화되어 관리됩니다!** 🚀
